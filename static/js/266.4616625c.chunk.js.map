{"version":3,"file":"static/js/266.4616625c.chunk.js","mappings":"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","sources":["src/libs/gif/NeuQuant.js","src/libs/gif/LZWEncoder.js","src/libs/gif/GIFEncoder.js","src/workers/generateGif.worker.js"],"sourcesContent":["/*\n * NeuQuant Neural-Net Quantization Algorithm\n * ------------------------------------------\n *\n * Copyright (c) 1994 Anthony Dekker\n *\n * NEUQUANT Neural-Net quantization algorithm by Anthony Dekker, 1994. See\n * \"Kohonen neural networks for optimal colour quantization\" in \"Network:\n * Computation in Neural Systems\" Vol. 5 (1994) pp 351-367. for a discussion of\n * the algorithm.\n *\n * Any party obtaining a copy of these files from the author, directly or\n * indirectly, is granted, free of charge, a full and unrestricted irrevocable,\n * world-wide, paid up, royalty-free, nonexclusive right and license to deal in\n * this software and documentation files (the \"Software\"), including without\n * limitation the rights to use, copy, modify, merge, publish, distribute,\n * sublicense, and/or sell copies of the Software, and to permit persons who\n * receive copies from any such party to do so, with the only requirement being\n * that this copyright notice remain intact.\n */\n\n/*\n * This class handles Neural-Net quantization algorithm\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n * @version 0.1 AS3 implementation\n */\n\nconst NeuQuant = function() {\n\n  var exports = {};\n  var netsize = 256; /* number of colours used */\n\n  /* four primes near 500 - assume no image has a length so large */\n  /* that it is divisible by all four primes */\n\n  var prime1 = 499;\n  var prime2 = 491;\n  var prime3 = 487;\n  var prime4 = 503;\n  var minpicturebytes = (3 * prime4); /* minimum size for input image */\n\n  /*\n   * Program Skeleton ---------------- [select samplefac in range 1..30] [read\n   * image from input file] pic = (unsigned char*) malloc(3*width*height);\n   * initnet(pic,3*width*height,samplefac); learn(); unbiasnet(); [write output\n   * image header, using writecolourmap(f)] inxbuild(); write output image using\n   * inxsearch(b,g,r)\n   */\n\n  /*\n   * Network Definitions -------------------\n   */\n\n  var maxnetpos = (netsize - 1);\n  var netbiasshift = 4; /* bias for colour values */\n  var ncycles = 100; /* no. of learning cycles */\n\n  /* defs for freq and bias */\n  var intbiasshift = 16; /* bias for fractions */\n  var intbias = (1 << intbiasshift);\n  var gammashift = 10; /* gamma = 1024 */\n  var gamma = (1 << gammashift);\n  var betashift = 10;\n  var beta = (intbias >> betashift); /* beta = 1/1024 */\n  var betagamma = (intbias << (gammashift - betashift));\n\n  /* defs for decreasing radius factor */\n  var initrad = (netsize >> 3); /* for 256 cols, radius starts */\n  var radiusbiasshift = 6; /* at 32.0 biased by 6 bits */\n  var radiusbias = (1 << radiusbiasshift);\n  var initradius = (initrad * radiusbias); /* and decreases by a */\n  var radiusdec = 30; /* factor of 1/30 each cycle */\n\n  /* defs for decreasing alpha factor */\n  var alphabiasshift = 10; /* alpha starts at 1.0 */\n  var initalpha = (1 << alphabiasshift);\n  var alphadec; /* biased by 10 bits */\n\n  /* radbias and alpharadbias used for radpower calculation */\n  var radbiasshift = 8;\n  var radbias = (1 << radbiasshift);\n  var alpharadbshift = (alphabiasshift + radbiasshift);\n  var alpharadbias = (1 << alpharadbshift);\n\n  /*\n   * Types and Global Variables --------------------------\n   */\n\n  var thepicture; /* the input image itself */\n  var lengthcount; /* lengthcount = H*W*3 */\n  var samplefac; /* sampling factor 1..30 */\n\n  // typedef int pixel[4]; /* BGRc */\n  var network; /* the network itself - [netsize][4] */\n  var netindex = [];\n\n  /* for network lookup - really 256 */\n  var bias = [];\n\n  /* bias and freq arrays for learning */\n  var freq = [];\n  var radpower = [];\n\n  var NeuQuant = exports.NeuQuant = function NeuQuant(thepic, len, sample) {\n\n    var i;\n    var p;\n\n    thepicture = thepic;\n    lengthcount = len;\n    samplefac = sample;\n\n    network = new Array(netsize);\n\n    for (i = 0; i < netsize; i++) {\n\n      network[i] = new Array(4);\n      p = network[i];\n      p[0] = p[1] = p[2] = (i << (netbiasshift + 8)) / netsize;\n      freq[i] = intbias / netsize; /* 1/netsize */\n      bias[i] = 0;\n    }\n  };\n\n  var colorMap = function colorMap() {\n\n    var map = [];\n    var index = new Array(netsize);\n\n    for (var i = 0; i < netsize; i++)\n      index[network[i][3]] = i;\n\n    var k = 0;\n    for (var l = 0; l < netsize; l++) {\n      var j = index[l];\n      map[k++] = (network[j][0]);\n      map[k++] = (network[j][1]);\n      map[k++] = (network[j][2]);\n    }\n\n    return map;\n  };\n\n  /*\n   * Insertion sort of network and building of netindex[0..255] (to do after\n   * unbias)\n   * -------------------------------------------------------------------------------\n   */\n\n  var inxbuild = function inxbuild() {\n\n    var i;\n    var j;\n    var smallpos;\n    var smallval;\n    var p;\n    var q;\n    var previouscol;\n    var startpos;\n\n    previouscol = 0;\n    startpos = 0;\n    for (i = 0; i < netsize; i++) {\n\n      p = network[i];\n      smallpos = i;\n      smallval = p[1]; /* index on g */\n\n      /* find smallest in i..netsize-1 */\n      for (j = i + 1; j < netsize; j++) {\n\n        q = network[j];\n        if (q[1] < smallval) { /* index on g */\n          smallpos = j;\n          smallval = q[1]; /* index on g */\n        }\n      }\n      q = network[smallpos];\n\n      /* swap p (i) and q (smallpos) entries */\n      if (i != smallpos) {\n        j = q[0];\n        q[0] = p[0];\n        p[0] = j;\n        j = q[1];\n        q[1] = p[1];\n        p[1] = j;\n        j = q[2];\n        q[2] = p[2];\n        p[2] = j;\n        j = q[3];\n        q[3] = p[3];\n        p[3] = j;\n      }\n\n      /* smallval entry is now in position i */\n\n      if (smallval != previouscol) {\n\n        netindex[previouscol] = (startpos + i) >> 1;\n\n        for (j = previouscol + 1; j < smallval; j++) netindex[j] = i;\n\n        previouscol = smallval;\n        startpos = i;\n      }\n    }\n\n    netindex[previouscol] = (startpos + maxnetpos) >> 1;\n    for (j = previouscol + 1; j < 256; j++) netindex[j] = maxnetpos; /* really 256 */\n  };\n\n  /*\n   * Main Learning Loop ------------------\n   */\n\n  var learn = function learn() {\n\n    var i;\n    var j;\n    var b;\n    var g;\n    var r;\n    var radius;\n    var rad;\n    var alpha;\n    var step;\n    var delta;\n    var samplepixels;\n    var p;\n    var pix;\n    var lim;\n\n    if (lengthcount < minpicturebytes) samplefac = 1;\n\n    alphadec = 30 + ((samplefac - 1) / 3);\n    p = thepicture;\n    pix = 0;\n    lim = lengthcount;\n    samplepixels = lengthcount / (3 * samplefac);\n    delta = (samplepixels / ncycles) | 0;\n    alpha = initalpha;\n    radius = initradius;\n\n    rad = radius >> radiusbiasshift;\n    if (rad <= 1) rad = 0;\n\n    for (i = 0; i < rad; i++) radpower[i] = alpha * (((rad * rad - i * i) * radbias) / (rad * rad));\n\n    if (lengthcount < minpicturebytes) step = 3;\n\n    else if ((lengthcount % prime1) !== 0) step = 3 * prime1;\n\n    else {\n\n      if ((lengthcount % prime2) !== 0) step = 3 * prime2;\n      else {\n        if ((lengthcount % prime3) !== 0) step = 3 * prime3;\n        else step = 3 * prime4;\n      }\n    }\n\n    i = 0;\n    while (i < samplepixels) {\n\n      b = (p[pix + 0] & 0xff) << netbiasshift;\n      g = (p[pix + 1] & 0xff) << netbiasshift;\n      r = (p[pix + 2] & 0xff) << netbiasshift;\n      j = contest(b, g, r);\n\n      altersingle(alpha, j, b, g, r);\n      if (rad !== 0) alterneigh(rad, j, b, g, r); /* alter neighbours */\n\n      pix += step;\n      if (pix >= lim) pix -= lengthcount;\n\n      i++;\n\n      if (delta === 0) delta = 1;\n\n      if (i % delta === 0) {\n        alpha -= alpha / alphadec;\n        radius -= radius / radiusdec;\n        rad = radius >> radiusbiasshift;\n\n        if (rad <= 1) rad = 0;\n\n        for (j = 0; j < rad; j++) radpower[j] = alpha * (((rad * rad - j * j) * radbias) / (rad * rad));\n      }\n    }\n  };\n\n  /*\n   ** Search for BGR values 0..255 (after net is unbiased) and return colour\n   * index\n   * ----------------------------------------------------------------------------\n   */\n\n  var map = exports.map = function map(b, g, r) {\n\n    var i;\n    var j;\n    var dist;\n    var a;\n    var bestd;\n    var p;\n    var best;\n\n    bestd = 1000; /* biggest possible dist is 256*3 */\n    best = -1;\n    i = netindex[g]; /* index on g */\n    j = i - 1; /* start at netindex[g] and work outwards */\n\n    while ((i < netsize) || (j >= 0)) {\n\n      if (i < netsize) {\n        p = network[i];\n        dist = p[1] - g; /* inx key */\n\n        if (dist >= bestd) i = netsize; /* stop iter */\n\n        else {\n\n          i++;\n          if (dist < 0) dist = -dist;\n          a = p[0] - b;\n          if (a < 0) a = -a;\n          dist += a;\n\n          if (dist < bestd) {\n            a = p[2] - r;\n            if (a < 0) a = -a;\n            dist += a;\n\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3];\n            }\n          }\n        }\n      }\n\n      if (j >= 0) {\n\n        p = network[j];\n        dist = g - p[1]; /* inx key - reverse dif */\n\n        if (dist >= bestd) j = -1; /* stop iter */\n\n        else {\n\n          j--;\n          if (dist < 0) dist = -dist;\n          a = p[0] - b;\n          if (a < 0) a = -a;\n          dist += a;\n\n          if (dist < bestd) {\n            a = p[2] - r;\n            if (a < 0) a = -a;\n            dist += a;\n            if (dist < bestd) {\n              bestd = dist;\n              best = p[3];\n            }\n          }\n        }\n      }\n    }\n\n    return (best);\n  };\n\n  var process = exports.process = function process() {\n    learn();\n    unbiasnet();\n    inxbuild();\n    return colorMap();\n  };\n\n  /*\n   * Unbias network to give byte values 0..255 and record position i to prepare\n   * for sort\n   * -----------------------------------------------------------------------------------\n   */\n\n  var unbiasnet = function unbiasnet() {\n\n    var i;\n    var j;\n\n    for (i = 0; i < netsize; i++) {\n      network[i][0] >>= netbiasshift;\n      network[i][1] >>= netbiasshift;\n      network[i][2] >>= netbiasshift;\n      network[i][3] = i; /* record colour no */\n    }\n  };\n\n  /*\n   * Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2)) in\n   * radpower[|i-j|]\n   * ---------------------------------------------------------------------------------\n   */\n\n  var alterneigh = function alterneigh(rad, i, b, g, r) {\n\n    var j;\n    var k;\n    var lo;\n    var hi;\n    var a;\n    var m;\n    var p;\n\n    lo = i - rad;\n    if (lo < -1) lo = -1;\n\n    hi = i + rad;\n    if (hi > netsize) hi = netsize;\n\n    j = i + 1;\n    k = i - 1;\n    m = 1;\n\n    while ((j < hi) || (k > lo)) {\n      a = radpower[m++];\n\n      if (j < hi) {\n        p = network[j++];\n\n        try {\n          p[0] -= (a * (p[0] - b)) / alpharadbias;\n          p[1] -= (a * (p[1] - g)) / alpharadbias;\n          p[2] -= (a * (p[2] - r)) / alpharadbias;\n        } catch (e) {} // prevents 1.3 miscompilation\n      }\n\n      if (k > lo) {\n        p = network[k--];\n\n        try {\n          p[0] -= (a * (p[0] - b)) / alpharadbias;\n          p[1] -= (a * (p[1] - g)) / alpharadbias;\n          p[2] -= (a * (p[2] - r)) / alpharadbias;\n        } catch (e) {}\n      }\n    }\n  };\n\n  /*\n   * Move neuron i towards biased (b,g,r) by factor alpha\n   * ----------------------------------------------------\n   */\n\n  var altersingle = function altersingle(alpha, i, b, g, r) {\n\n    /* alter hit neuron */\n    var n = network[i];\n    n[0] -= (alpha * (n[0] - b)) / initalpha;\n    n[1] -= (alpha * (n[1] - g)) / initalpha;\n    n[2] -= (alpha * (n[2] - r)) / initalpha;\n  };\n\n  /*\n   * Search for biased BGR values ----------------------------\n   */\n\n  var contest = function contest(b, g, r) {\n\n    /* finds closest neuron (min dist) and updates freq */\n    /* finds best neuron (min dist-bias) and returns position */\n    /* for frequently chosen neurons, freq[i] is high and bias[i] is negative */\n    /* bias[i] = gamma*((1/netsize)-freq[i]) */\n\n    var i;\n    var dist;\n    var a;\n    var biasdist;\n    var betafreq;\n    var bestpos;\n    var bestbiaspos;\n    var bestd;\n    var bestbiasd;\n    var n;\n\n    bestd = ~ (1 << 31);\n    bestbiasd = bestd;\n    bestpos = -1;\n    bestbiaspos = bestpos;\n\n    for (i = 0; i < netsize; i++) {\n      n = network[i];\n      dist = n[0] - b;\n      if (dist < 0) dist = -dist;\n      a = n[1] - g;\n      if (a < 0) a = -a;\n      dist += a;\n      a = n[2] - r;\n      if (a < 0) a = -a;\n      dist += a;\n\n      if (dist < bestd) {\n        bestd = dist;\n        bestpos = i;\n      }\n\n      biasdist = dist - ((bias[i]) >> (intbiasshift - netbiasshift));\n\n      if (biasdist < bestbiasd) {\n        bestbiasd = biasdist;\n        bestbiaspos = i;\n      }\n\n      betafreq = (freq[i] >> betashift);\n      freq[i] -= betafreq;\n      bias[i] += (betafreq << gammashift);\n    }\n\n    freq[bestpos] += beta;\n    bias[bestpos] -= betagamma;\n    return (bestbiaspos);\n  };\n\n  NeuQuant.apply(this, arguments);\n  return exports;\n};\n\nexport default NeuQuant;\n","/**\n * This class handles LZW encoding\n * Adapted from Jef Poskanzer's Java port by way of J. M. G. Elliott.\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n * @version 0.1 AS3 implementation\n */\n\nconst LZWEncoder = function() {\n\n  var exports = {};\n  var EOF = -1;\n  var imgW;\n  var imgH;\n  var pixAry;\n  var initCodeSize;\n  var remaining;\n  var curPixel;\n\n  // GIFCOMPR.C - GIF Image compression routines\n  // Lempel-Ziv compression based on 'compress'. GIF modifications by\n  // David Rowley (mgardi@watdcsu.waterloo.edu)\n  // General DEFINEs\n\n  var BITS = 12;\n  var HSIZE = 5003; // 80% occupancy\n\n  // GIF Image compression - modified 'compress'\n  // Based on: compress.c - File compression ala IEEE Computer, June 1984.\n  // By Authors: Spencer W. Thomas (decvax!harpo!utah-cs!utah-gr!thomas)\n  // Jim McKie (decvax!mcvax!jim)\n  // Steve Davies (decvax!vax135!petsd!peora!srd)\n  // Ken Turkowski (decvax!decwrl!turtlevax!ken)\n  // James A. Woods (decvax!ihnp4!ames!jaw)\n  // Joe Orost (decvax!vax135!petsd!joe)\n\n  var n_bits; // number of bits/code\n  var maxbits = BITS; // user settable max # bits/code\n  var maxcode; // maximum code, given n_bits\n  var maxmaxcode = 1 << BITS; // should NEVER generate this code\n  var htab = [];\n  var codetab = [];\n  var hsize = HSIZE; // for dynamic table sizing\n  var free_ent = 0; // first unused entry\n\n  // block compression parameters -- after all codes are used up,\n  // and compression rate changes, start over.\n\n  var clear_flg = false;\n\n  // Algorithm: use open addressing double hashing (no chaining) on the\n  // prefix code / next character combination. We do a variant of Knuth's\n  // algorithm D (vol. 3, sec. 6.4) along with G. Knott's relatively-prime\n  // secondary probe. Here, the modular division first probe is gives way\n  // to a faster exclusive-or manipulation. Also do block compression with\n  // an adaptive reset, whereby the code table is cleared when the compression\n  // ratio decreases, but after the table fills. The variable-length output\n  // codes are re-sized at this point, and a special CLEAR code is generated\n  // for the decompressor. Late addition: construct the table according to\n  // file size for noticeable speed improvement on small files. Please direct\n  // questions about this implementation to ames!jaw.\n\n  var g_init_bits;\n  var ClearCode;\n  var EOFCode;\n\n  // output\n  // Output the given code.\n  // Inputs:\n  // code: A n_bits-bit integer. If == -1, then EOF. This assumes\n  // that n_bits =< wordsize - 1.\n  // Outputs:\n  // Outputs code to the file.\n  // Assumptions:\n  // Chars are 8 bits long.\n  // Algorithm:\n  // Maintain a BITS character long buffer (so that 8 codes will\n  // fit in it exactly). Use the VAX insv instruction to insert each\n  // code in turn. When the buffer fills up empty it and start over.\n\n  var cur_accum = 0;\n  var cur_bits = 0;\n  var masks = [0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF];\n\n  // Number of characters so far in this 'packet'\n  var a_count;\n\n  // Define the storage for the packet accumulator\n  var accum = [];\n\n  var LZWEncoder = exports.LZWEncoder = function LZWEncoder(width, height, pixels, color_depth) {\n    imgW = width;\n    imgH = height;\n    pixAry = pixels;\n    initCodeSize = Math.max(2, color_depth);\n  };\n\n  // Add a character to the end of the current packet, and if it is 254\n  // characters, flush the packet to disk.\n  var char_out = function char_out(c, outs) {\n    accum[a_count++] = c;\n    if (a_count >= 254) flush_char(outs);\n  };\n\n  // Clear out the hash table\n  // table clear for block compress\n\n  var cl_block = function cl_block(outs) {\n    cl_hash(hsize);\n    free_ent = ClearCode + 2;\n    clear_flg = true;\n    output(ClearCode, outs);\n  };\n\n  // reset code table\n  var cl_hash = function cl_hash(hsize) {\n    for (var i = 0; i < hsize; ++i) htab[i] = -1;\n  };\n\n  var compress = exports.compress = function compress(init_bits, outs) {\n\n    var fcode;\n    var i; /* = 0 */\n    var c;\n    var ent;\n    var disp;\n    var hsize_reg;\n    var hshift;\n\n    // Set up the globals: g_init_bits - initial number of bits\n    g_init_bits = init_bits;\n\n    // Set up the necessary values\n    clear_flg = false;\n    n_bits = g_init_bits;\n    maxcode = MAXCODE(n_bits);\n\n    ClearCode = 1 << (init_bits - 1);\n    EOFCode = ClearCode + 1;\n    free_ent = ClearCode + 2;\n\n    a_count = 0; // clear packet\n\n    ent = nextPixel();\n\n    hshift = 0;\n    for (fcode = hsize; fcode < 65536; fcode *= 2)\n      ++hshift;\n    hshift = 8 - hshift; // set hash code range bound\n\n    hsize_reg = hsize;\n    cl_hash(hsize_reg); // clear hash table\n\n    output(ClearCode, outs);\n\n    outer_loop: while ((c = nextPixel()) != EOF) {\n      fcode = (c << maxbits) + ent;\n      i = (c << hshift) ^ ent; // xor hashing\n\n      if (htab[i] == fcode) {\n        ent = codetab[i];\n        continue;\n      }\n\n      else if (htab[i] >= 0) { // non-empty slot\n\n        disp = hsize_reg - i; // secondary hash (after G. Knott)\n        if (i === 0) disp = 1;\n\n        do {\n          if ((i -= disp) < 0)\n            i += hsize_reg;\n\n          if (htab[i] == fcode) {\n            ent = codetab[i];\n            continue outer_loop;\n          }\n        } while (htab[i] >= 0);\n      }\n\n      output(ent, outs);\n      ent = c;\n      if (free_ent < maxmaxcode) {\n        codetab[i] = free_ent++; // code -> hashtable\n        htab[i] = fcode;\n      }\n      else cl_block(outs);\n    }\n\n    // Put out the final code.\n    output(ent, outs);\n    output(EOFCode, outs);\n  };\n\n  // ----------------------------------------------------------------------------\n  var encode = exports.encode = function encode(os) {\n    os.writeByte(initCodeSize); // write \"initial code size\" byte\n    remaining = imgW * imgH; // reset navigation variables\n    curPixel = 0;\n    compress(initCodeSize + 1, os); // compress and write the pixel data\n    os.writeByte(0); // write block terminator\n  };\n\n  // Flush the packet to disk, and reset the accumulator\n  var flush_char = function flush_char(outs) {\n    if (a_count > 0) {\n      outs.writeByte(a_count);\n      outs.writeBytes(accum, 0, a_count);\n      a_count = 0;\n    }\n  };\n\n  var MAXCODE = function MAXCODE(n_bits) {\n    return (1 << n_bits) - 1;\n  };\n\n  // ----------------------------------------------------------------------------\n  // Return the next pixel from the image\n  // ----------------------------------------------------------------------------\n\n  var nextPixel = function nextPixel() {\n    if (remaining === 0) return EOF;\n    --remaining;\n    var pix = pixAry[curPixel++];\n    return pix & 0xff;\n  };\n\n  var output = function output(code, outs) {\n\n    cur_accum &= masks[cur_bits];\n\n    if (cur_bits > 0) cur_accum |= (code << cur_bits);\n    else cur_accum = code;\n\n    cur_bits += n_bits;\n\n    while (cur_bits >= 8) {\n      char_out((cur_accum & 0xff), outs);\n      cur_accum >>= 8;\n      cur_bits -= 8;\n    }\n\n    // If the next entry is going to be too big for the code size,\n    // then increase it, if possible.\n\n    if (free_ent > maxcode || clear_flg) {\n\n      if (clear_flg) {\n\n        maxcode = MAXCODE(n_bits = g_init_bits);\n        clear_flg = false;\n\n      } else {\n\n        ++n_bits;\n        if (n_bits == maxbits) maxcode = maxmaxcode;\n        else maxcode = MAXCODE(n_bits);\n      }\n    }\n\n    if (code == EOFCode) {\n\n      // At EOF, write the rest of the buffer.\n      while (cur_bits > 0) {\n        char_out((cur_accum & 0xff), outs);\n        cur_accum >>= 8;\n        cur_bits -= 8;\n      }\n\n      flush_char(outs);\n    }\n  };\n\n  LZWEncoder.apply(this, arguments);\n  return exports;\n};\n\nexport default LZWEncoder;\n","/**\n * This class lets you encode animated GIF files\n * Base class :  http://www.java2s.com/Code/Java/2D-Graphics-GUI/AnimatedGifEncoder.htm\n * @author Kevin Weiner (original Java version - kweiner@fmsware.com)\n * @author Thibault Imbert (AS3 version - bytearray.org)\n * @author Kevin Kwok (JavaScript version - https://github.com/antimatter15/jsgif)\n * @version 0.1 AS3 implementation\n */\nimport NeuQuant from './NeuQuant';\nimport LZWEncoder from './LZWEncoder';\n\nconst GIFEncoder = function() {\n\n  for (var i = 0, chr = {}; i < 256; i++)\n    chr[i] = String.fromCharCode(i);\n\n  function ByteArray() {\n    this.bin = [];\n  }\n\n  ByteArray.prototype.getData = function() {\n    for (var v = '', l = this.bin.length, i = 0; i < l; i++)\n      v += chr[this.bin[i]];\n    return v;\n  };\n\n  ByteArray.prototype.writeByte = function(val) {\n    this.bin.push(val);\n  };\n\n  ByteArray.prototype.writeUTFBytes = function(string) {\n    for (var l = string.length, i = 0; i < l; i++)\n      this.writeByte(string.charCodeAt(i));\n  };\n\n  ByteArray.prototype.writeBytes = function(array, offset, length) {\n    for (var l = length || array.length, i = offset || 0; i < l; i++)\n      this.writeByte(array[i]);\n  };\n\n  var exports = {};\n  var width; // image size\n  var height;\n  var transparent = null; // transparent color if given\n  var transIndex; // transparent index in color table\n  var repeat = -1; // no repeat\n  var delay = 0; // frame delay (hundredths)\n  var started = false; // ready to output frames\n  var out;\n  var image; // current frame\n  var pixels; // BGR byte array from frame\n  var indexedPixels; // converted frame indexed to palette\n  var colorDepth; // number of bit planes\n  var colorTab; // RGB palette\n  var usedEntry = []; // active palette entries\n  var palSize = 7; // color table size (bits-1)\n  var dispose = -1; // disposal code (-1 = use default)\n  var closeStream = false; // close stream when finished\n  var firstFrame = true;\n  var sizeSet = false; // if false, get size from first frame\n  var sample = 10; // default sample interval for quantizer\n  var comment = \"\"; // default comment for generated gif\n\n  /**\n   * Sets the delay time between each frame, or changes it for subsequent frames\n   * (applies to last frame added)\n   * int delay time in milliseconds\n   * @param ms\n   */\n\n  var setDelay = exports.setDelay = function setDelay(ms) {\n    delay = Math.round(ms / 10);\n  };\n\n  /**\n   * Sets the GIF frame disposal code for the last added frame and any\n   *\n   * subsequent frames. Default is 0 if no transparent color has been set,\n   * otherwise 2.\n   * @param code\n   * int disposal code.\n   */\n\n  var setDispose = exports.setDispose = function setDispose(code) {\n    if (code >= 0) dispose = code;\n  };\n\n  /**\n   * Sets the number of times the set of GIF frames should be played. Default is\n   * 1; 0 means play indefinitely. Must be invoked before the first image is\n   * added.\n   *\n   * @param iter\n   * int number of iterations.\n   * @return\n   */\n\n  var setRepeat = exports.setRepeat = function setRepeat(iter) {\n    if (iter >= 0) repeat = iter;\n  };\n\n  /**\n   * Sets the transparent color for the last added frame and any subsequent\n   * frames. Since all colors are subject to modification in the quantization\n   * process, the color in the final palette for each frame closest to the given\n   * color becomes the transparent color for that frame. May be set to null to\n   * indicate no transparent color.\n   * @param\n   * Color to be treated as transparent on display.\n   */\n\n  var setTransparent = exports.setTransparent = function setTransparent(c) {\n    transparent = c;\n  };\n\n\n  /**\n   * Sets the comment for the block comment\n   * @param\n   * string to be insterted as comment\n   */\n\n  var setComment = exports.setComment = function setComment(c) {\n    comment = c;\n  };\n\n\n\n  /**\n   * The addFrame method takes an incoming BitmapData object to create each frames\n   * @param\n   * BitmapData object to be treated as a GIF's frame\n   */\n\n  var addFrame = exports.addFrame = function addFrame(im, is_imageData) {\n\n    if ((im === null) || !started || out === null) {\n      throw new Error(\"Please call start method before calling addFrame\");\n    }\n\n    var ok = true;\n\n    try {\n      if (!is_imageData) {\n        image = im.getImageData(0, 0, im.canvas.width, im.canvas.height).data;\n        if (!sizeSet) setSize(im.canvas.width, im.canvas.height);\n      } else {\n        image = im;\n      }\n      getImagePixels(); // convert to correct format if necessary\n      analyzePixels(); // build color table & map pixels\n\n      if (firstFrame) {\n        writeLSD(); // logical screen descriptior\n        writePalette(); // global color table\n        if (repeat >= 0) {\n          // use NS app extension to indicate reps\n          writeNetscapeExt();\n        }\n      }\n\n      writeGraphicCtrlExt(); // write graphic control extension\n      if (comment !== '') {\n        writeCommentExt(); // write comment extension\n      }\n      writeImageDesc(); // image descriptor\n      if (!firstFrame) writePalette(); // local color table\n      writePixels(); // encode and write pixel data\n      firstFrame = false;\n    } catch (e) {\n      ok = false;\n    }\n\n    return ok;\n  };\n\n  /**\n   * Adds final trailer to the GIF stream, if you don't call the finish method\n   * the GIF stream will not be valid.\n   */\n\n  var finish = exports.finish = function finish() {\n\n    if (!started) return false;\n\n    var ok = true;\n    started = false;\n\n    try {\n      out.writeByte(0x3b); // gif trailer\n    } catch (e) {\n      ok = false;\n    }\n\n    return ok;\n  };\n\n  /**\n   * Resets some members so that a new stream can be started.\n   * This method is actually called by the start method\n   */\n\n  var reset = function reset() {\n\n    // reset for subsequent use\n    transIndex = 0;\n    image = null;\n    pixels = null;\n    indexedPixels = null;\n    colorTab = null;\n    closeStream = false;\n    firstFrame = true;\n  };\n\n  /**\n   * * Sets frame rate in frames per second. Equivalent to\n   * <code>setDelay(1000/fps)</code>.\n   * @param fps\n   * float frame rate (frames per second)\n   */\n\n  var setFrameRate = exports.setFrameRate = function setFrameRate(fps) {\n    if (fps != 0xf) delay = Math.round(100 / fps);\n  };\n\n  /**\n   * Sets quality of color quantization (conversion of images to the maximum 256\n   * colors allowed by the GIF specification). Lower values (minimum = 1)\n   * produce better colors, but slow processing significantly. 10 is the\n   * default, and produces good color mapping at reasonable speeds. Values\n   * greater than 20 do not yield significant improvements in speed.\n   * @param quality\n   * int greater than 0.\n   * @return\n   */\n\n  var setQuality = exports.setQuality = function setQuality(quality) {\n    if (quality < 1) quality = 1;\n    sample = quality;\n  };\n\n  /**\n   * Sets the GIF frame size. The default size is the size of the first frame\n   * added if this method is not invoked.\n   * @param w\n   * int frame width.\n   * @param h\n   * int frame width.\n   */\n\n  var setSize = exports.setSize = function setSize(w, h) {\n\n    if (started && !firstFrame) return;\n    width = w;\n    height = h;\n    if (width < 1) width = 320;\n    if (height < 1) height = 240;\n    sizeSet = true;\n  };\n\n  /**\n   * Initiates GIF file creation on the given stream.\n   * @param os\n   * OutputStream on which GIF images are written.\n   * @return false if initial write failed.\n   */\n\n  var start = exports.start = function start() {\n\n    reset();\n    var ok = true;\n    closeStream = false;\n    out = new ByteArray();\n    try {\n      out.writeUTFBytes(\"GIF89a\"); // header\n    } catch (e) {\n      ok = false;\n    }\n\n    return started = ok;\n  };\n\n  var cont = exports.cont = function cont() {\n\n    reset();\n    var ok = true;\n    closeStream = false;\n    out = new ByteArray();\n\n    return started = ok;\n  };\n\n  /**\n   * Analyzes image colors and creates color map.\n   */\n\n  var analyzePixels = function analyzePixels() {\n\n    var len = pixels.length;\n    var nPix = len / 3;\n    indexedPixels = [];\n    var nq = new NeuQuant(pixels, len, sample);\n\n    // initialize quantizer\n    colorTab = nq.process(); // create reduced palette\n\n    // map image pixels to new palette\n    var k = 0;\n    for (var j = 0; j < nPix; j++) {\n      var index = nq.map(pixels[k++] & 0xff, pixels[k++] & 0xff, pixels[k++] & 0xff);\n      usedEntry[index] = true;\n      indexedPixels[j] = index;\n    }\n\n    pixels = null;\n    colorDepth = 8;\n    palSize = 7;\n\n    // get closest match to transparent color if specified\n    if (transparent !== null) {\n      transIndex = findClosest(transparent);\n    }\n  };\n\n  /**\n   * Returns index of palette color closest to c\n   */\n\n  var findClosest = function findClosest(c) {\n\n    if (colorTab === null) return -1;\n    var r = (c & 0xFF0000) >> 16;\n    var g = (c & 0x00FF00) >> 8;\n    var b = (c & 0x0000FF);\n    var minpos = 0;\n    var dmin = 256 * 256 * 256;\n    var len = colorTab.length;\n\n    for (var i = 0; i < len;) {\n      var dr = r - (colorTab[i++] & 0xff);\n      var dg = g - (colorTab[i++] & 0xff);\n      var db = b - (colorTab[i] & 0xff);\n      var d = dr * dr + dg * dg + db * db;\n      var index = i / 3 | 0;\n      if (usedEntry[index] && (d < dmin)) {\n        dmin = d;\n        minpos = index;\n      }\n      i++;\n    }\n    return minpos;\n  };\n\n  /**\n   * Extracts image pixels into byte array \"pixels\n   */\n\n  var getImagePixels = function getImagePixels() {\n    var w = width;\n    var h = height;\n    pixels = [];\n    var data = image;\n    var count = 0;\n\n    for (var i = 0; i < h; i++) {\n\n      for (var j = 0; j < w; j++) {\n\n        var b = (i * w * 4) + j * 4;\n        pixels[count++] = data[b];\n        pixels[count++] = data[b + 1];\n        pixels[count++] = data[b + 2];\n\n      }\n\n    }\n  };\n\n  /**\n   * Writes Graphic Control Extension\n   */\n\n  var writeGraphicCtrlExt = function writeGraphicCtrlExt() {\n    out.writeByte(0x21); // extension introducer\n    out.writeByte(0xf9); // GCE label\n    out.writeByte(4); // data block size\n    var transp;\n    var disp;\n    if (transparent === null) {\n      transp = 0;\n      disp = 0; // dispose = no action\n    } else {\n      transp = 1;\n      disp = 2; // force clear if using transparent color\n    }\n    if (dispose >= 0) {\n      disp = dispose & 7; // user override\n    }\n    disp <<= 2;\n    // packed fields\n    out.writeByte(0 | // 1:3 reserved\n      disp | // 4:6 disposal\n      0 | // 7 user input - 0 = none\n      transp); // 8 transparency flag\n\n    WriteShort(delay); // delay x 1/100 sec\n    out.writeByte(transIndex); // transparent color index\n    out.writeByte(0); // block terminator\n  };\n\n  /**\n   * Writes Comment Extention\n   */\n\n  var writeCommentExt = function writeCommentExt() {\n    out.writeByte(0x21); // extension introducer\n    out.writeByte(0xfe); // comment label\n    out.writeByte(comment.length); // Block Size (s)\n    out.writeUTFBytes(comment);\n    out.writeByte(0); // block terminator\n  };\n\n\n  /**\n   * Writes Image Descriptor\n   */\n\n  var writeImageDesc = function writeImageDesc() {\n\n    out.writeByte(0x2c); // image separator\n    WriteShort(0); // image position x,y = 0,0\n    WriteShort(0);\n    WriteShort(width); // image size\n    WriteShort(height);\n\n    // packed fields\n    if (firstFrame) {\n      // no LCT - GCT is used for first (or only) frame\n      out.writeByte(0);\n    } else {\n      // specify normal LCT\n      out.writeByte(0x80 | // 1 local color table 1=yes\n        0 | // 2 interlace - 0=no\n        0 | // 3 sorted - 0=no\n        0 | // 4-5 reserved\n        palSize); // 6-8 size of color table\n    }\n  };\n\n  /**\n   * Writes Logical Screen Descriptor\n   */\n\n  var writeLSD = function writeLSD() {\n\n    // logical screen size\n    WriteShort(width);\n    WriteShort(height);\n    // packed fields\n    out.writeByte((0x80 | // 1 : global color table flag = 1 (gct used)\n      0x70 | // 2-4 : color resolution = 7\n      0x00 | // 5 : gct sort flag = 0\n      palSize)); // 6-8 : gct size\n\n    out.writeByte(0); // background color index\n    out.writeByte(0); // pixel aspect ratio - assume 1:1\n  };\n\n  /**\n   * Writes Netscape application extension to define repeat count.\n   */\n\n  var writeNetscapeExt = function writeNetscapeExt() {\n    out.writeByte(0x21); // extension introducer\n    out.writeByte(0xff); // app extension label\n    out.writeByte(11); // block size\n    out.writeUTFBytes(\"NETSCAPE\" + \"2.0\"); // app id + auth code\n    out.writeByte(3); // sub-block size\n    out.writeByte(1); // loop sub-block id\n    WriteShort(repeat); // loop count (extra iterations, 0=repeat forever)\n    out.writeByte(0); // block terminator\n  };\n\n  /**\n   * Writes color table\n   */\n\n  var writePalette = function writePalette() {\n    out.writeBytes(colorTab);\n    var n = (3 * 256) - colorTab.length;\n    for (var i = 0; i < n; i++) out.writeByte(0);\n  };\n\n  var WriteShort = function WriteShort(pValue) {\n    out.writeByte(pValue & 0xFF);\n    out.writeByte((pValue >> 8) & 0xFF);\n  };\n\n  /**\n   * Encodes and writes pixel data\n   */\n\n  var writePixels = function writePixels() {\n    var myencoder = new LZWEncoder(width, height, indexedPixels, colorDepth);\n    myencoder.encode(out);\n  };\n\n  /**\n   * Retrieves the GIF stream\n   */\n\n  var stream = exports.stream = function stream() {\n    return out;\n  };\n\n  var setProperties = exports.setProperties = function setProperties(has_start, is_first) {\n    started = has_start;\n    firstFrame = is_first;\n  };\n\n  return exports;\n\n};\n\nexport default GIFEncoder;\n","// bundle.worker.js code lines will from 56791 to 1182 in Web\n// if not import react-native like\n// import {Platform} from 'react-native';\n// if (Platform.OS !== 'web') {\n//   var self = require('@minar-kotonoha/react-native-threads').self;\n// }\n// so\n// for Android and iOS: /generateGif.worker.js\n// for Web: /src/workers/generateGif.worker.js\n\nimport GIFEncoder from '../libs/gif/GIFEncoder';\n\n// below is same with /generateGif.worker.js\n// =======\n\nself.onmessage = (event) => {\n  // we need to check if imageDataArr has transparent color in it\n  // and if it does - specify it in encoder, otherwise - don't specify it\n  // this hack is made because encoder takes the closest color to transparent and makes it transparent\n  // TODO: this is so not ideal, if imageDataArr has black color - it will be transparent\n  // Need to rework this, to deal with the \"REAL\" black\n  const isTransparencyPresent = (imageDataArr, transparentColor) => {\n    let i = 0,\n      transpUsed = -1;\n    const len = imageDataArr.length;\n\n    for (; i < len; ) {\n      transpUsed *=\n        imageDataArr[i++] -\n        transparentColor.r +\n        imageDataArr[i++] -\n        transparentColor.g +\n        imageDataArr[i++] -\n        transparentColor.b;\n\n      i++;\n\n      if (!transpUsed) {\n        break;\n      }\n      transpUsed = -1;\n    }\n    return !transpUsed;\n  };\n\n  const data = typeof event === 'string' ? JSON.parse(event) : event.data;\n  const {\n    frameUUID,\n    frameNum,\n    framesLength,\n    height,\n    width,\n    fps,\n    imageData,\n  } = data;\n\n  const encoder = new GIFEncoder(); // create a new GIFEncoder for every new job\n  const transparentColor = 0x000000;\n  const transpRGB = {r: 0, g: 0, b: 0};\n\n  const useTransparency = isTransparencyPresent(imageData, transpRGB);\n\n  encoder.setRepeat(0);\n  // we need to set disposal code of 2 for each frame\n  // to be sure that the current frame will override the previous and won't overlap\n  encoder.setDispose(2);\n  encoder.setQuality(1);\n  encoder.setFrameRate(fps);\n  encoder.setSize(width, height);\n\n  if (useTransparency) {\n    encoder.setTransparent(transparentColor);\n  } else {\n    encoder.setTransparent(null);\n  }\n\n  if (frameNum === 0) {\n    encoder.start();\n  } else {\n    encoder.cont();\n    encoder.setProperties(true, false); // started, firstFrame\n  }\n\n  encoder.addFrame(imageData, true);\n\n  if (framesLength === frameNum + 1) {\n    encoder.finish();\n  }\n\n  const res = {\n    frameUUID,\n    frameIndex: frameNum,\n    frameData: encoder.stream().getData(),\n  };\n  self.postMessage(typeof event === 'string' ? JSON.stringify(res) : res);\n};\n"],"names":["alphadec","thepicture","lengthcount","samplefac","network","exports","netsize","prime1","prime2","prime3","prime4","minpicturebytes","maxnetpos","netbiasshift","ncycles","intbiasshift","intbias","gammashift","betashift","beta","betagamma","initrad","radiusbiasshift","radiusbias","initradius","radiusdec","alphabiasshift","initalpha","radbiasshift","radbias","alpharadbshift","alpharadbias","netindex","bias","freq","radpower","NeuQuant","thepic","len","sample","i","p","Array","colorMap","map","index","k","l","j","inxbuild","smallpos","smallval","q","previouscol","startpos","learn","b","g","r","radius","rad","alpha","step","delta","samplepixels","pix","lim","contest","altersingle","alterneigh","unbiasnet","dist","a","bestd","best","process","lo","hi","m","e","n","biasdist","betafreq","bestpos","bestbiaspos","bestbiasd","apply","this","arguments","imgW","imgH","pixAry","initCodeSize","remaining","curPixel","n_bits","maxcode","g_init_bits","ClearCode","EOFCode","a_count","EOF","BITS","HSIZE","maxbits","maxmaxcode","htab","codetab","hsize","free_ent","clear_flg","cur_accum","cur_bits","masks","accum","LZWEncoder","width","height","pixels","color_depth","Math","max","char_out","c","outs","flush_char","cl_block","cl_hash","output","compress","init_bits","fcode","ent","disp","hsize_reg","hshift","MAXCODE","nextPixel","outer_loop","encode","os","writeByte","writeBytes","code","chr","String","fromCharCode","ByteArray","bin","prototype","getData","v","length","val","push","writeUTFBytes","string","charCodeAt","array","offset","transIndex","out","image","indexedPixels","colorDepth","colorTab","transparent","repeat","delay","started","usedEntry","palSize","dispose","firstFrame","sizeSet","comment","reset","setDelay","ms","round","setDispose","setRepeat","iter","setTransparent","setComment","addFrame","im","is_imageData","Error","ok","getImageData","canvas","data","setSize","getImagePixels","analyzePixels","writeLSD","writePalette","writeNetscapeExt","writeGraphicCtrlExt","writeCommentExt","writeImageDesc","writePixels","finish","setFrameRate","fps","setQuality","quality","w","h","start","cont","nPix","nq","findClosest","minpos","dmin","dr","dg","db","d","count","transp","WriteShort","pValue","stream","setProperties","has_start","is_first","self","onmessage","event","JSON","parse","frameUUID","frameNum","framesLength","imageData","encoder","GIFEncoder","useTransparency","imageDataArr","transparentColor","transpUsed","isTransparencyPresent","res","frameIndex","frameData","postMessage","stringify"],"sourceRoot":""}